{
  "version": 3,
  "sources": ["../../exponential-backoff/src/options.ts", "../../exponential-backoff/src/jitter/full/full.jitter.ts", "../../exponential-backoff/src/jitter/no/no.jitter.ts", "../../exponential-backoff/src/jitter/jitter.factory.ts", "../../exponential-backoff/src/delay/delay.base.ts", "../../exponential-backoff/src/delay/skip-first/skip-first.delay.ts", "../../exponential-backoff/src/delay/always/always.delay.ts", "../../exponential-backoff/src/delay/delay.factory.ts", "../../exponential-backoff/src/backoff.ts"],
  "sourcesContent": ["/**\n * Type of jitter to apply to the delay.\n * - `\"none\"`: no jitter is applied\n * - `\"full\"`: full jitter is applied (random value between `0` and `delay`)\n */\nexport type JitterType = \"none\" | \"full\";\n\nexport type BackoffOptions = Partial<IBackOffOptions>;\n\nexport interface IBackOffOptions {\n  /**\n   * Decides whether the `startingDelay` should be applied before the first call.\n   * If `false`, the first call will occur without a delay.\n   * @defaultValue `false`\n   */\n  delayFirstAttempt: boolean;\n  /**\n   * Decides whether a [jitter](https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/)\n   * should be applied to the delay. Possible values are `\"full\"` and `\"none\"`.\n   * @defaultValue `\"none\"`\n   */\n  jitter: JitterType;\n  /**\n   * The maximum delay, in milliseconds, between two consecutive attempts.\n   * @defaultValue `Infinity`\n   */\n  maxDelay: number;\n  /**\n   * The maximum number of times to attempt the function.\n   * Must be at least `1`.\n   * @defaultValue `10`\n   */\n  numOfAttempts: number;\n  /**\n   * The `retry` function can be used to run logic after every failed attempt (e.g. logging a message,\n   * assessing the last error, etc.).\n   * It is called with the last error and the upcoming attempt number.\n   * Returning `true` will retry the function as long as the `numOfAttempts` has not been exceeded.\n   * Returning `false` will end the execution.\n   * @defaultValue a function that always returns `true`.\n   * @param e The last error thrown by the function.\n   * @param attemptNumber The upcoming attempt number.\n   * @returns `true` to retry the function, `false` to end the execution\n   */\n  retry: (e: any, attemptNumber: number) => boolean | Promise<boolean>;\n  /**\n   * The delay, in milliseconds, before executing the function for the first time.\n   * @defaultValue `100`\n   */\n  startingDelay: number;\n  /**\n   * The `startingDelay` is multiplied by the `timeMultiple` to increase the delay between reattempts.\n   * @defaultValue `2`\n   */\n  timeMultiple: number;\n}\n\nconst defaultOptions: IBackOffOptions = {\n  delayFirstAttempt: false,\n  jitter: \"none\",\n  maxDelay: Infinity,\n  numOfAttempts: 10,\n  retry: () => true,\n  startingDelay: 100,\n  timeMultiple: 2\n};\n\nexport function getSanitizedOptions(options: BackoffOptions) {\n  const sanitized: IBackOffOptions = { ...defaultOptions, ...options };\n\n  if (sanitized.numOfAttempts < 1) {\n    sanitized.numOfAttempts = 1;\n  }\n\n  return sanitized;\n}\n", "export function fullJitter(delay: number) {\n    const jitteredDelay = Math.random() * delay;\n    return Math.round(jitteredDelay);\n}", "export function noJitter(delay: number) {\n    return delay;\n}", "import { IBackOffOptions } from \"../options\";\nimport { fullJitter } from \"./full/full.jitter\";\nimport { noJitter } from \"./no/no.jitter\";\n\nexport type Jitter = (delay: number) => number;\n\nexport function JitterFactory(options: IBackOffOptions): Jitter {\n  switch (options.jitter) {\n    case \"full\":\n      return fullJitter;\n\n    case \"none\":\n    default:\n      return noJitter;\n  }\n}\n", "import { IDelay } from \"./delay.interface\";\nimport { IBackOffOptions } from \"../options\";\nimport { JitterFactory } from \"../jitter/jitter.factory\";\n\nexport abstract class Delay implements IDelay {\n  protected attempt = 0;\n  constructor(private options: IBackOffOptions) {}\n\n  public apply() {\n    return new Promise(resolve => setTimeout(resolve, this.jitteredDelay));\n  }\n\n  public setAttemptNumber(attempt: number) {\n    this.attempt = attempt;\n  }\n\n  private get jitteredDelay() {\n    const jitter = JitterFactory(this.options);\n    return jitter(this.delay);\n  }\n\n  private get delay() {\n    const constant = this.options.startingDelay;\n    const base = this.options.timeMultiple;\n    const power = this.numOfDelayedAttempts;\n    const delay = constant * Math.pow(base, power);\n\n    return Math.min(delay, this.options.maxDelay);\n  }\n\n  protected get numOfDelayedAttempts() {\n    return this.attempt;\n  }\n}\n", "import { Delay } from \"../delay.base\";\n\nexport class SkipFirstDelay extends Delay {\n    public async apply() {\n        return this.isFirstAttempt ? true : super.apply();\n    }\n\n    private get isFirstAttempt() {\n        return this.attempt === 0;\n    }\n\n    protected get numOfDelayedAttempts() {\n        return this.attempt - 1;\n    }\n}", "import { Delay } from \"../delay.base\";\n\nexport class AlwaysDelay extends Delay {}", "import { IBackOffOptions } from \"../options\";\nimport { SkipFirstDelay } from \"./skip-first/skip-first.delay\";\nimport { AlwaysDelay } from \"./always/always.delay\";\nimport { IDelay } from \"./delay.interface\";\n\nexport function DelayFactory(options: IBackOffOptions, attempt: number): IDelay {\n    const delay = initDelayClass(options);\n    delay.setAttemptNumber(attempt);\n    return delay;\n}\n\nfunction initDelayClass(options: IBackOffOptions) {\n    if (!options.delayFirstAttempt) {\n        return new SkipFirstDelay(options);\n    }\n\n    return new AlwaysDelay(options);\n}", "import {\n  IBackOffOptions,\n  getSanitizedOptions,\n  BackoffOptions\n} from \"./options\";\nimport { DelayFactory } from \"./delay/delay.factory\";\n\nexport { BackoffOptions, IBackOffOptions };\n\n/**\n * Executes a function with exponential backoff.\n * @param request the function to be executed\n * @param options options to customize the backoff behavior\n * @returns Promise that resolves to the result of the `request` function\n */\nexport async function backOff<T>(\n  request: () => Promise<T>,\n  options: BackoffOptions = {}\n): Promise<T> {\n  const sanitizedOptions = getSanitizedOptions(options);\n  const backOff = new BackOff(request, sanitizedOptions);\n\n  return await backOff.execute();\n}\n\nclass BackOff<T> {\n  private attemptNumber = 0;\n\n  constructor(\n    private request: () => Promise<T>,\n    private options: IBackOffOptions\n  ) {}\n\n  public async execute(): Promise<T> {\n    while (!this.attemptLimitReached) {\n      try {\n        await this.applyDelay();\n        return await this.request();\n      } catch (e) {\n        this.attemptNumber++;\n        const shouldRetry = await this.options.retry(e, this.attemptNumber);\n\n        if (!shouldRetry || this.attemptLimitReached) {\n          throw e;\n        }\n      }\n    }\n\n    throw new Error(\"Something went wrong.\");\n  }\n\n  private get attemptLimitReached() {\n    return this.attemptNumber >= this.options.numOfAttempts;\n  }\n\n  private async applyDelay() {\n    const delay = DelayFactory(this.options, this.attemptNumber);\n    await delay.apply();\n  }\n}\n"],
  "mappings": "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",
  "names": ["Delay", "SkipFirstDelay", "AlwaysDelay", "backOff", "BackOff"]
}
